\section{Hardware Implementation} \label{sec:hardware}
This section presents the step by step implementation of simple pick and place task in the real robot.

Usage:\\
\texttt{>> test\_pick\_and\_place}\\
\subsection{Hardware Setup} \label{subsec:hardware_setup}
At this stage we adjust the manipulator to the desired home position and recorded the joint angles corresponding to this home pose using Dynamixel wizard.
We also recorded the maximum and minimum joint angles for each motor using Dynamixel wizard.
The range of motion and velocity for each motor is shown in Table \ref{tab:range_of_motion_velocity}.
\begin{table}[h]
        \centering
        \caption{Range of motion and velocity for each motor}
        \label{tab:range_of_motion_velocity}
        \begin{tabular}{|c||c|l|}
                \hline
                \textbf{Motor Type} & \textbf{Range of Motion}     & \textbf{Velocity}               \\ \hline \hline
                Ax                  & $[0 - 1023] \to [0-300^0]  $ & $[0 - 1023]\to  [0-114rpm]$     \\ \hline
                Mx                  & $[0 - 4094] \to [0-360^0] $  & $ [0 - 1023] \to [0-116.62rpm]$ \\ \hline
        \end{tabular}
\end{table}

\subsection{Brief Description of the Code} \label{subsec:brief_description_code}
The functions used in the hardware implementation are listed below,
\begin{itemize}
        \item  $joint2motor$: converts joint angles from radian to manipulator units.
        \item  $traj\_pos\_joint2motor$: converts matrix of joint angles from radian to manipulator units by calling $joint2motor$ in a loop.
        \item  $vel\_rpm2dxl$: converts joint velocity from $rpm$ to manipulator units.
        \item  $traj\_vel\_joint2motor$: converts matrix of joint velocities from $rpm$ to manipulator units, by calling $vel\_rpm2dxl$ in a loop.
        \item  $open\_port$: establish communication by opening the port and setting the baud rate, specify the port from devide manager here.
        \item  $write\_data$: sends joint angles and velocities to all the motors simultaneously.
        \item  $sync\_send$: sends matrix of joint angles and velocities by calling $write\_data$ in a loop.
        \item  $gripper$: Opens and closes the gripper as required.
        \item  $close\_port$: for terminating session by closing the port.
        \item  $enable\_torque$: enables the torque of the manipulator motors, and also used to see if all the motors are working properly.
        \item  $disable\_torque$: disables the torque of the manipulator motors.
\end{itemize}
The script $test\_pick\_and\_place$ uses all the above functions to perform the pick and place task.

\cleardoublepage
\subsection{Pick and place task graph (Basic Algorithm)} \label{subsec:pick_and_place_task}
The task execution process is sequential and straightforward and is shown in Figure \ref{fig:fsm}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[H] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
        \centering % centers the figure
        \begin{tikzpicture}
                % nodes
                \node[state, initial, minimum height=1.6cm, text width=3cm, align=center] (s1) {Go to home pose};
                \node[state, right of=s1, minimum height=1.6cm, xshift=1.5cm, text width=3cm, align=center] (s2) {Generate pick\\parameters};
                \node[state, right of=s2, minimum height=1.6cm, xshift=1.5cm, text width=3cm, align=center] (s3) {Go to pre-\\pick pose};
                \node[state, below of=s3, minimum height=1.6cm, text width=3cm, align=center] (s4) {Open the \\gripper};
                \node[state, below of=s4, minimum height=1.6cm,  text width=3cm, align=center] (s5) {Go to pick \\pose};
                \node[state, left of=s5, minimum height=1.6cm, xshift=-1.5cm, text width=3cm, align=center] (s6) {Close the \\gripper};
                \node[state, above of=s6, minimum height=1.6cm, text width=3cm, align=center] (s7) {Retract to pre-pick \\pose};
                \node[state, left of=s7, minimum height=1.6cm, xshift=-1.5cm, text width=3cm, align=center] (s8) {Generate place\\parameters};
                \node[state, below of=s8, minimum height=1.6cm, text width=3cm, align=center] (s9) {Go to pre-\\place pose};
                \node[state, below of=s9, minimum height=1.6cm, text width=3cm, align=center] (s10) {Go to \\place pose};
                \node[state, right of=s10, minimum height=1.6cm, xshift=1.5cm, text width=3cm, align=center] (s11) {Open the \\gripper};
                \node[state, below of=s10, minimum height=1.6cm, text width=3cm, align=center] (s12) {Retract to pre-\\place pose};

                \node[state, left of=s1, minimum height=1.6cm, xshift=-1.5cm,  text width=3cm, align=center] (e1) {Singular config. \\\textcolor{red}{Terminate}};


                % edges
                \draw[->] (s1) edge node[above] {} (s2);
                \draw[->, green] (s2) edge node[above] {OK} (s3);
                \draw[->] (s3) edge node[right] {} (s4);
                \draw[->] (s4) edge node[right] {} (s5);
                \draw[->] (s5) edge node[above] {} (s6);
                \draw[->] (s6) edge node[right] {} (s7);
                \draw[->] (s7) edge node[above] {} (s8);
                \draw[->, green] (s8) edge node[right] {Ok} (s9);
                \draw[->] (s9) edge node[right] {} (s10);
                \draw[->] (s10) edge node[right] {} (s11);
                \draw[->] (s11.east) to[out=-10, in=0, looseness=2] (s12.east);
                \draw[->] (s12) edge[bend left=60] node[above] {} (s1);

                \draw[->, red] (s2.north) to[out=120, in=60, looseness=1.5] node[above, sloped] {Error} (e1.north);
                \draw[->, red] (s8.west) to[out=180, in=-90, looseness=1.5] node[below, sloped] {Error} (e1.south);

        \end{tikzpicture}
        \caption{Task graph}
        \label{fig:fsm}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Please note that, an  \textcolor{red}{error} is generated in the $inv\_kine$ function if a pose that results in singular confuguration is provided.\\
Please also note that the first initialization step before performing any task is to open the port, set baud rate, and enable torque.\\
The last steps are to disable the torque and close the port.\\\\
Description of the task graph:\\
\begin{enumerate}
        \item  Go to home pose: Initially the manipulator could be at any pose. Therefore, using the home pose joint angles recorded previously, we should go to the home pose first.
        \item  Generate pick parameters: Here we generate the trajectory to got to the pre-pick and pick poses. While performing the inverse kinematics we could encounter an error if singular configuration is provided.
        \item  Go to pre-pick pose: Done by sending the trajectory that connects home pose and pre-pick pose.
        \item  Open the gripper.
        \item  Go to pick pose.
        \item  Close the gripper.
        \item  Retract to pre-pick pose.
        \item  Generate place parameters: done in the same way as pick parameters are generated.
        \item  Go to pre-place pose: done in the same way as pre-pick pose is reached.
        \item  Go to place pose.
        \item  Open the gripper.
        \item  Retract to pre-place pose.
\end{enumerate}
Finally, the pick and place execution can be put in a loop to perform the task multiple times. 
\cleardoublepage
\section{Conclusion} \label{sec:conclusion}
In this project we have analyzed and tested the kinematics of 6 dof anthropomorphic arm with spherical wrist,
done joint space trajectory planning using LSPB and task space trajectory planning using linear interpolation.
Finally, we have simulated our work using Peter Corke's Robotics Toolbox and shown the implementation in the real robot.